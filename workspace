#!/usr/bin/env bash
set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

CONFIG_FILE="$HOME/.workspaces.yml"

# ============================================================================
# Config parsing functions
# ============================================================================

check_config() {
    if [[ ! -f "$CONFIG_FILE" ]]; then
        echo -e "${RED}Error: Config file not found at $CONFIG_FILE${NC}"
        echo ""
        echo "Create it with the following format:"
        echo ""
        echo "projects:"
        echo "  myproject:"
        echo "    path: ~/projects/myproject/app"
        echo "    worktree_dir: ~/projects/myproject"
        exit 1
    fi
}

# Simple YAML parser for our specific format
# Gets a project's path or worktree_dir
get_project_config() {
    local project="$1"
    local key="$2"

    # Parse the YAML file to find the project section and extract the key
    awk -v proj="$project" -v key="$key" '
        /^  [a-zA-Z_-]+:$/ {
            current_project = $1
            gsub(/:$/, "", current_project)
        }
        current_project == proj && $1 == key":" {
            # Get value after the key, trim whitespace and comments
            val = $0
            sub(/^[^:]+:[ \t]*/, "", val)
            sub(/[ \t]*#.*$/, "", val)
            print val
            exit
        }
    ' "$CONFIG_FILE"
}

# Expand ~ to $HOME
expand_path() {
    local path="$1"
    echo "${path/#\~/$HOME}"
}

# List all configured projects
list_projects() {
    awk '/^  [a-zA-Z_-]+:$/ {
        proj = $1
        gsub(/:$/, "", proj)
        print proj
    }' "$CONFIG_FILE"
}

# Validate project exists in config
validate_project() {
    local project="$1"
    local projects
    projects=$(list_projects)

    if ! echo "$projects" | grep -qx "$project"; then
        echo -e "${RED}Error: Unknown project '$project'${NC}"
        echo ""
        echo "Available projects:"
        echo "$projects" | sed 's/^/  /'
        exit 1
    fi
}

# Get project paths
get_project_paths() {
    local project="$1"

    PROJECT_PATH=$(expand_path "$(get_project_config "$project" "path")")
    WORKTREE_DIR=$(expand_path "$(get_project_config "$project" "worktree_dir")")

    if [[ -z "$PROJECT_PATH" ]] || [[ -z "$WORKTREE_DIR" ]]; then
        echo -e "${RED}Error: Project '$project' is missing path or worktree_dir in config${NC}"
        exit 1
    fi

    if [[ ! -d "$PROJECT_PATH" ]]; then
        echo -e "${RED}Error: Project path does not exist: $PROJECT_PATH${NC}"
        exit 1
    fi
}

# Sanitize a branch/feature name for use as a directory name (replace / with -)
sanitize_dir_name() {
    echo "${1//\//-}"
}

# Find the next available Redis DB number (1-15) by scanning ALL projects' worktrees
next_free_redis_db() {
    local used_dbs=""

    # Scan worktrees across all configured projects (they share the same Redis)
    for project in $(list_projects); do
        local proj_path
        proj_path=$(expand_path "$(get_project_config "$project" "path")")
        [[ -d "$proj_path" ]] || continue

        while IFS= read -r line; do
            local wt_path
            wt_path=$(echo "$line" | awk '{print $1}')
            if [[ -f "$wt_path/.env" ]]; then
                local db
                db=$(grep '^REDIS_URL=' "$wt_path/.env" | sed 's|.*redis://[^/]*/||' | tr -d '"' || true)
                if [[ -n "$db" ]]; then
                    used_dbs="$used_dbs $db"
                fi
            fi
        done <<< "$(git -C "$proj_path" worktree list 2>/dev/null)"
    done

    for db in $(seq 1 15); do
        if ! echo "$used_dbs" | grep -qw "$db"; then
            echo "$db"
            return
        fi
    done

    echo -e "${RED}Warning: All Redis DBs (1-15) are in use${NC}" >&2
    echo "1"
}

# Find an unused port by scanning ALL projects' worktrees for VITE_RUBY_PORT
next_free_port() {
    local used_ports=""

    for project in $(list_projects); do
        local proj_path
        proj_path=$(expand_path "$(get_project_config "$project" "path")")
        [[ -d "$proj_path" ]] || continue

        while IFS= read -r line; do
            local wt_path
            wt_path=$(echo "$line" | awk '{print $1}')
            if [[ -f "$wt_path/.env" ]]; then
                local port
                port=$(grep '^VITE_RUBY_PORT=' "$wt_path/.env" | cut -d= -f2 | tr -d '"' || true)
                if [[ -n "$port" ]]; then
                    used_ports="$used_ports $port $((port + 2))"
                fi
            fi
        done <<< "$(git -C "$proj_path" worktree list 2>/dev/null)"
    done

    local attempts=0
    while (( attempts < 50 )); do
        local candidate=$((3100 + RANDOM % 800))
        if ! echo "$used_ports" | grep -qw "$candidate" && \
           ! echo "$used_ports" | grep -qw "$((candidate + 2))"; then
            echo "$candidate"
            return
        fi
        ((attempts++))
    done

    echo -e "${RED}Warning: Could not find an unused port after 50 attempts${NC}" >&2
    echo "$((3100 + RANDOM % 800))"
}

# Resolve the actual worktree path for a feature.
# If the config-derived path isn't a worktree, search git worktree list by branch name.
resolve_worktree_path() {
    local project="$1"
    local feature="$2"
    local config_dir="$WORKTREE_DIR/$(sanitize_dir_name "$feature")"

    # Check if the config-derived path is a known worktree
    if git -C "$PROJECT_PATH" worktree list | grep -q "^$config_dir "; then
        echo "$config_dir"
        return
    fi

    # Fall back: search by directory name or branch name
    local found_path
    found_path=$(git -C "$PROJECT_PATH" worktree list | awk -v feat="/$feature " -v branch="[$feature]" '$0 ~ feat || $3 == branch {print $1; exit}')

    if [[ -n "$found_path" ]]; then
        echo "$found_path"
        return
    fi

    # Nothing found
    echo ""
}

# ============================================================================
# Subcommand: new
# ============================================================================

cmd_new() {
    local project="$1"
    local feature="$2"

    if [[ -z "$project" ]] || [[ -z "$feature" ]]; then
        echo "Usage: workspace new <project> <feature>"
        echo ""
        echo "Example: workspace new tract my-feature"
        exit 1
    fi

    validate_project "$project"
    get_project_paths "$project"

    local workspace_dir="$WORKTREE_DIR/$(sanitize_dir_name "$feature")"

    # Check if directory already exists
    if [[ -d "$workspace_dir" ]]; then
        echo -e "${RED}Error: Directory $workspace_dir already exists${NC}"
        exit 1
    fi

    local random_port
    random_port=$(next_free_port)
    local rails_port=$((random_port + 2))
    local server_url="http://localhost:$rails_port"
    local session_cookie="${project}_cookie_${rails_port}"
    local redis_db
    redis_db=$(next_free_redis_db)

    echo -e "${GREEN}Creating new workspace: $feature${NC}"
    echo -e "  Project:             $project"
    echo -e "  Workspace directory: $workspace_dir"
    echo -e "  Vite port:           $random_port"
    echo -e "  Rails port:          $rails_port"
    echo -e "  Session cookie:      $session_cookie"
    echo -e "  Redis DB:            $redis_db"
    echo ""

    # Fetch latest from origin
    echo -e "${YELLOW}Fetching latest from origin...${NC}"
    git -C "$PROJECT_PATH" fetch origin master

    # Create new worktree with a new branch
    echo -e "${YELLOW}Creating git worktree...${NC}"
    git -C "$PROJECT_PATH" worktree add -b "$feature" "$workspace_dir" origin/master

    # Copy .env file if it exists in main workspace
    if [[ -f "$PROJECT_PATH/.env" ]]; then
        echo -e "${YELLOW}Copying .env file...${NC}"
        cp "$PROJECT_PATH/.env" "$workspace_dir/.env"
    fi

    # Copy Claude Code settings so permissions carry over
    if [[ -f "$PROJECT_PATH/.claude/settings.local.json" ]]; then
        echo -e "${YELLOW}Copying Claude Code settings...${NC}"
        mkdir -p "$workspace_dir/.claude"
        cp "$PROJECT_PATH/.claude/settings.local.json" "$workspace_dir/.claude/settings.local.json"
    fi

    # Update .env file with workspace-specific settings
    echo -e "${YELLOW}Configuring .env...${NC}"

    # Remove existing workspace-specific vars if present
    if [[ -f "$workspace_dir/.env" ]]; then
        grep -v '^SESSION_COOKIE_NAME=' "$workspace_dir/.env" | grep -v '^VITE_RUBY_PORT=' | grep -v '^REDIS_URL=' > "$workspace_dir/.env.tmp" || true
        mv "$workspace_dir/.env.tmp" "$workspace_dir/.env"
    fi

    # Append workspace-specific settings
    cat >> "$workspace_dir/.env" << EOF

# Workspace-specific settings (port: $random_port)
SESSION_COOKIE_NAME="$session_cookie"
VITE_RUBY_PORT=$random_port
REDIS_URL=redis://localhost:6379/$redis_db
EOF

    # Create .env.test to force Vite to compile instead of proxying to dev server
    cat > "$workspace_dir/.env.test" << EOF
VITE_RUBY_PORT=3037
EOF

    # Create a workspace-specific Procfile
    echo -e "${YELLOW}Creating Procfile.workspace...${NC}"
    local template_file="$PROJECT_PATH/Procfile.workspace.template"

    if [[ -f "$template_file" ]]; then
        # Use project-specific template with variable substitution
        sed -e "s/\$RAILS_PORT/$rails_port/g" \
            -e "s/\$VITE_PORT/$random_port/g" \
            "$template_file" > "$workspace_dir/Procfile.workspace"
    else
        # Default Rails Procfile
        cat > "$workspace_dir/Procfile.workspace" << EOF
web: RUBY_DEBUG_OPEN=true bin/rails server -p $rails_port
vite: VITE_RUBY_PORT=$random_port bin/vite dev
worker: RUBY_DEBUG_OPEN=true bundle exec sidekiq -C config/sidekiq.yml
EOF
    fi

    # Create tmux session
    local tmux_session="${project}-${feature}"
    echo -e "${YELLOW}Creating tmux session: $tmux_session${NC}"

    # Create docs directory and feature notes file
    mkdir -p "$workspace_dir/docs"
    cat > "$workspace_dir/docs/$feature.md" << EOF
# New Feature - $feature

---
Server URL:  $server_url
Git branch:  $feature
Path:        $workspace_dir
---

Start describing your new feature...
EOF

    # Create tmux session with first window for coding
    tmux new-session -d -s "$tmux_session" -c "$workspace_dir" -n "code"

    # Split first window vertically: vim on left, shell on right
    tmux send-keys -t "$tmux_session:code" "vim docs/$feature.md" C-m
    tmux split-window -h -t "$tmux_session:code" -c "$workspace_dir"

    # Create banner file and display in shell pane
    cat > "$workspace_dir/.banner" << EOF

   ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
   ┃  Project: $project
   ┃  Feature: $feature
   ┃  Server:  $server_url
   ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

EOF
    tmux send-keys -t "$tmux_session:code.1" "clear && cat .banner" C-m

    # Create second window for server
    tmux new-window -t "$tmux_session" -c "$workspace_dir" -n "server"

    # Create a setup script that runs in the server window
    cat > "$workspace_dir/.workspace-setup.sh" << 'SETUP_SCRIPT'
#!/usr/bin/env bash
set -e

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

echo -e "${YELLOW}Setting up node version...${NC}"
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"
nvm use

echo -e "${YELLOW}Installing dependencies...${NC}"
echo -e "  Running bundle install..."
if ! bundle install; then
    echo -e "${RED}bundle install failed${NC}"
    exit 1
fi

echo -e "  Running yarn install..."
if ! yarn install; then
    echo -e "${RED}yarn install failed${NC}"
    exit 1
fi

echo ""
echo -e "${GREEN}Setup complete!${NC}"
echo ""
SETUP_SCRIPT

    # Append the server start to the setup script
    cat >> "$workspace_dir/.workspace-setup.sh" << EOF
echo ""
echo -e "${GREEN}Starting overmind...${NC}"
echo ""
rm -f "\$0"  # Clean up this script
exec overmind start -f Procfile.workspace
EOF

    chmod +x "$workspace_dir/.workspace-setup.sh"

    # Run the setup script in the server window
    tmux send-keys -t "$tmux_session:server" "./.workspace-setup.sh" C-m

    # Go back to first window, focus on vim pane
    tmux select-window -t "$tmux_session:code"
    tmux select-pane -t "$tmux_session:code.0"

    echo ""
    echo -e "${GREEN}Workspace created!${NC}"
    echo ""
    echo -e "  Tmux session: ${YELLOW}$tmux_session${NC}"
    echo -e "  Server URL:   ${YELLOW}$server_url${NC}"
    echo ""
    echo -e "Switch to session:"
    echo -e "  ${YELLOW}tmux switch-client -t $tmux_session${NC}"
    echo ""
    echo -e "Or if not in tmux:"
    echo -e "  ${YELLOW}tmux attach -t $tmux_session${NC}"
    echo ""
    echo -e "To delete this workspace later:"
    echo -e "  ${YELLOW}workspace delete $project $feature${NC}"
}

# ============================================================================
# Subcommand: pull
# ============================================================================

cmd_pull() {
    local project="$1"
    local branch="$2"

    if [[ -z "$project" ]] || [[ -z "$branch" ]]; then
        echo "Usage: workspace pull <project> <branch>"
        echo ""
        echo "Example: workspace pull tract remote-branch"
        exit 1
    fi

    validate_project "$project"
    get_project_paths "$project"

    local workspace_dir="$WORKTREE_DIR/$(sanitize_dir_name "$branch")"

    # Check if directory already exists
    if [[ -d "$workspace_dir" ]]; then
        echo -e "${RED}Error: Directory $workspace_dir already exists${NC}"
        exit 1
    fi

    local random_port
    random_port=$(next_free_port)
    local rails_port=$((random_port + 2))
    local server_url="http://localhost:$rails_port"
    local session_cookie="${project}_cookie_${rails_port}"

    local redis_db
    redis_db=$(next_free_redis_db)

    echo -e "${GREEN}Pulling remote branch: $branch${NC}"
    echo -e "  Project:             $project"
    echo -e "  Workspace directory: $workspace_dir"
    echo -e "  Vite port:           $random_port"
    echo -e "  Rails port:          $rails_port"
    echo -e "  Session cookie:      $session_cookie"
    echo -e "  Redis DB:            $redis_db"
    echo ""

    # Fetch the remote branch
    echo -e "${YELLOW}Fetching branch from origin...${NC}"
    git -C "$PROJECT_PATH" fetch origin "$branch"

    # Create worktree tracking the remote branch
    echo -e "${YELLOW}Creating git worktree...${NC}"
    git -C "$PROJECT_PATH" worktree add --track -b "$branch" "$workspace_dir" "origin/$branch"

    # Copy .env file if it exists in main workspace
    if [[ -f "$PROJECT_PATH/.env" ]]; then
        echo -e "${YELLOW}Copying .env file...${NC}"
        cp "$PROJECT_PATH/.env" "$workspace_dir/.env"
    fi

    # Copy Claude Code settings so permissions carry over
    if [[ -f "$PROJECT_PATH/.claude/settings.local.json" ]]; then
        echo -e "${YELLOW}Copying Claude Code settings...${NC}"
        mkdir -p "$workspace_dir/.claude"
        cp "$PROJECT_PATH/.claude/settings.local.json" "$workspace_dir/.claude/settings.local.json"
    fi

    # Update .env file with workspace-specific settings
    echo -e "${YELLOW}Configuring .env...${NC}"

    # Remove existing workspace-specific vars if present
    if [[ -f "$workspace_dir/.env" ]]; then
        grep -v '^SESSION_COOKIE_NAME=' "$workspace_dir/.env" | grep -v '^VITE_RUBY_PORT=' | grep -v '^REDIS_URL=' > "$workspace_dir/.env.tmp" || true
        mv "$workspace_dir/.env.tmp" "$workspace_dir/.env"
    fi

    # Append workspace-specific settings
    cat >> "$workspace_dir/.env" << EOF

# Workspace-specific settings (port: $random_port)
SESSION_COOKIE_NAME="$session_cookie"
VITE_RUBY_PORT=$random_port
REDIS_URL=redis://localhost:6379/$redis_db
EOF

    # Create .env.test to force Vite to compile instead of proxying to dev server
    cat > "$workspace_dir/.env.test" << EOF
VITE_RUBY_PORT=3037
EOF

    # Create a workspace-specific Procfile
    echo -e "${YELLOW}Creating Procfile.workspace...${NC}"
    local template_file="$PROJECT_PATH/Procfile.workspace.template"

    if [[ -f "$template_file" ]]; then
        # Use project-specific template with variable substitution
        sed -e "s/\$RAILS_PORT/$rails_port/g" \
            -e "s/\$VITE_PORT/$random_port/g" \
            "$template_file" > "$workspace_dir/Procfile.workspace"
    else
        # Default Rails Procfile
        cat > "$workspace_dir/Procfile.workspace" << EOF
web: RUBY_DEBUG_OPEN=true bin/rails server -p $rails_port
vite: VITE_RUBY_PORT=$random_port bin/vite dev
worker: RUBY_DEBUG_OPEN=true bundle exec sidekiq -C config/sidekiq.yml
EOF
    fi

    # Create tmux session
    local tmux_session="${project}-${branch}"
    echo -e "${YELLOW}Creating tmux session: $tmux_session${NC}"

    # Create docs directory and feature notes file
    local notes_file="$workspace_dir/docs/$branch.md"
    mkdir -p "$(dirname "$notes_file")"

    # Try to fetch PR description from GitHub
    echo -e "${YELLOW}Fetching PR description from GitHub...${NC}"
    local pr_description=""
    local pr_title=""
    local pr_url=""

    # Get PR info for this branch (using gh CLI)
    if command -v gh &> /dev/null; then
        pr_url=$(gh pr view "$branch" --repo "$(git -C "$PROJECT_PATH" remote get-url origin)" --json url --jq '.url' 2>/dev/null || true)
        pr_title=$(gh pr view "$branch" --repo "$(git -C "$PROJECT_PATH" remote get-url origin)" --json title --jq '.title' 2>/dev/null || true)
        pr_description=$(gh pr view "$branch" --repo "$(git -C "$PROJECT_PATH" remote get-url origin)" --json body --jq '.body' 2>/dev/null || true)
    fi

    if [[ -n "$pr_title" ]]; then
        echo -e "  Found PR: ${CYAN}$pr_title${NC}"
        cat > "$notes_file" << EOF
# $pr_title

---
Server URL:  $server_url
Git branch:  $branch
Path:        $workspace_dir
PR:          $pr_url
---

## PR Description

$pr_description
EOF
    else
        echo -e "  ${YELLOW}No PR found for branch, creating basic notes file${NC}"
        cat > "$notes_file" << EOF
# $branch

---
Server URL:  $server_url
Git branch:  $branch
Path:        $workspace_dir
---

No PR found for this branch.
EOF
    fi

    # Create tmux session with first window for coding
    tmux new-session -d -s "$tmux_session" -c "$workspace_dir" -n "code"

    # Split first window vertically: vim on left, shell on right
    tmux send-keys -t "$tmux_session:code" "vim \"$notes_file\"" C-m
    tmux split-window -h -t "$tmux_session:code" -c "$workspace_dir"

    # Create banner file and display in shell pane
    cat > "$workspace_dir/.banner" << EOF

   ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
   ┃  Project: $project
   ┃  Branch:  $branch
   ┃  Server:  $server_url
   ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

EOF
    tmux send-keys -t "$tmux_session:code.1" "clear && cat .banner" C-m

    # Create second window for server
    tmux new-window -t "$tmux_session" -c "$workspace_dir" -n "server"

    # Create a setup script that runs in the server window
    cat > "$workspace_dir/.workspace-setup.sh" << 'SETUP_SCRIPT'
#!/usr/bin/env bash
set -e

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

echo -e "${YELLOW}Setting up node version...${NC}"
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"
nvm use

echo -e "${YELLOW}Installing dependencies...${NC}"
echo -e "  Running bundle install..."
if ! bundle install; then
    echo -e "${RED}bundle install failed${NC}"
    exit 1
fi

echo -e "  Running yarn install..."
if ! yarn install; then
    echo -e "${RED}yarn install failed${NC}"
    exit 1
fi

echo ""
echo -e "${GREEN}Setup complete!${NC}"
echo ""
SETUP_SCRIPT

    # Append the server start to the setup script
    cat >> "$workspace_dir/.workspace-setup.sh" << EOF
echo ""
echo -e "${GREEN}Starting overmind...${NC}"
echo ""
rm -f "\$0"  # Clean up this script
exec overmind start -f Procfile.workspace
EOF

    chmod +x "$workspace_dir/.workspace-setup.sh"

    # Run the setup script in the server window
    tmux send-keys -t "$tmux_session:server" "./.workspace-setup.sh" C-m

    # Go back to first window, focus on vim pane
    tmux select-window -t "$tmux_session:code"
    tmux select-pane -t "$tmux_session:code.0"

    echo ""
    echo -e "${GREEN}Workspace created from remote branch!${NC}"
    echo ""
    echo -e "  Tmux session: ${YELLOW}$tmux_session${NC}"
    echo -e "  Server URL:   ${YELLOW}$server_url${NC}"
    echo ""
    echo -e "Switch to session:"
    echo -e "  ${YELLOW}tmux switch-client -t $tmux_session${NC}"
    echo ""
    echo -e "Or if not in tmux:"
    echo -e "  ${YELLOW}tmux attach -t $tmux_session${NC}"
    echo ""
    echo -e "To delete this workspace later:"
    echo -e "  ${YELLOW}workspace delete $project $branch${NC}"
}

# ============================================================================
# Subcommand: resume
# ============================================================================

cmd_resume() {
    local project="$1"
    local feature="$2"

    if [[ -z "$project" ]] || [[ -z "$feature" ]]; then
        echo "Usage: workspace resume <project> <feature>"
        echo ""
        echo "Example: workspace resume tract my-feature"
        exit 1
    fi

    validate_project "$project"
    get_project_paths "$project"

    local workspace_dir
    workspace_dir=$(resolve_worktree_path "$project" "$feature")

    # If no worktree exists, check if the branch exists and create worktree from it
    if [[ -z "$workspace_dir" ]]; then
        # Check if the branch exists locally
        if ! git -C "$PROJECT_PATH" rev-parse --verify "$feature" &>/dev/null; then
            echo -e "${RED}Error: No worktree or branch found for '$feature'${NC}"
            echo ""
            echo "Use 'workspace new' or 'workspace pull' to create a workspace first."
            exit 1
        fi

        workspace_dir="$WORKTREE_DIR/$(sanitize_dir_name "$feature")"

        echo -e "${GREEN}Creating workspace from existing branch: $feature${NC}"

        # Generate ports and settings
        local random_port
        random_port=$(next_free_port)
        local rails_port=$((random_port + 2))
        local server_url="http://localhost:$rails_port"
        local session_cookie="${project}_cookie_${rails_port}"
        local redis_db
        redis_db=$(next_free_redis_db)

        echo -e "  Project:             $project"
        echo -e "  Workspace directory: $workspace_dir"
        echo -e "  Vite port:           $random_port"
        echo -e "  Rails port:          $rails_port"
        echo -e "  Session cookie:      $session_cookie"
        echo -e "  Redis DB:            $redis_db"
        echo ""

        # Create worktree from existing branch
        echo -e "${YELLOW}Creating git worktree...${NC}"
        git -C "$PROJECT_PATH" worktree add "$workspace_dir" "$feature"

        # Copy .env file if it exists in main workspace
        if [[ -f "$PROJECT_PATH/.env" ]]; then
            echo -e "${YELLOW}Copying .env file...${NC}"
            cp "$PROJECT_PATH/.env" "$workspace_dir/.env"
        fi

        # Copy Claude Code settings so permissions carry over
        if [[ -f "$PROJECT_PATH/.claude/settings.local.json" ]]; then
            echo -e "${YELLOW}Copying Claude Code settings...${NC}"
            mkdir -p "$workspace_dir/.claude"
            cp "$PROJECT_PATH/.claude/settings.local.json" "$workspace_dir/.claude/settings.local.json"
        fi

        # Update .env file with workspace-specific settings
        echo -e "${YELLOW}Configuring .env...${NC}"
        if [[ -f "$workspace_dir/.env" ]]; then
            grep -v '^SESSION_COOKIE_NAME=' "$workspace_dir/.env" | grep -v '^VITE_RUBY_PORT=' | grep -v '^REDIS_URL=' > "$workspace_dir/.env.tmp" || true
            mv "$workspace_dir/.env.tmp" "$workspace_dir/.env"
        fi

        cat >> "$workspace_dir/.env" << EOF

# Workspace-specific settings (port: $random_port)
SESSION_COOKIE_NAME="$session_cookie"
VITE_RUBY_PORT=$random_port
REDIS_URL=redis://localhost:6379/$redis_db
EOF

        # Create .env.test
        cat > "$workspace_dir/.env.test" << EOF
VITE_RUBY_PORT=3037
EOF

        # Create Procfile.workspace
        echo -e "${YELLOW}Creating Procfile.workspace...${NC}"
        local template_file="$PROJECT_PATH/Procfile.workspace.template"
        if [[ -f "$template_file" ]]; then
            sed -e "s/\$RAILS_PORT/$rails_port/g" \
                -e "s/\$VITE_PORT/$random_port/g" \
                "$template_file" > "$workspace_dir/Procfile.workspace"
        else
            cat > "$workspace_dir/Procfile.workspace" << EOF
web: RUBY_DEBUG_OPEN=true bin/rails server -p $rails_port
vite: VITE_RUBY_PORT=$random_port bin/vite dev
worker: RUBY_DEBUG_OPEN=true bundle exec sidekiq -C config/sidekiq.yml
EOF
        fi

        # Create docs directory and feature notes file
        mkdir -p "$workspace_dir/docs"
        if [[ ! -f "$workspace_dir/docs/$feature.md" ]]; then
            cat > "$workspace_dir/docs/$feature.md" << EOF
# $feature

---
Server URL:  $server_url
Git branch:  $feature
Path:        $workspace_dir
---
EOF
        fi

        # Fall through to tmux session creation below
    fi

    # Check if workspace exists on disk
    if [[ ! -d "$workspace_dir" ]]; then
        echo -e "${RED}Error: Workspace directory does not exist: $workspace_dir${NC}"
        exit 1
    fi

    # Derive tmux session name from the actual branch in the worktree
    local worktree_branch
    worktree_branch=$(git -C "$PROJECT_PATH" worktree list | awk -v dir="$workspace_dir " '$0 ~ dir {gsub(/[\[\]]/, "", $3); print $3; exit}')
    local tmux_session="${project}-${worktree_branch:-$feature}"

    # Check if tmux session already exists
    if tmux has-session -t "$tmux_session" 2>/dev/null; then
        echo -e "${YELLOW}Tmux session '$tmux_session' already exists${NC}"
        echo ""
        echo -e "Switch to session:"
        echo -e "  ${YELLOW}tmux switch-client -t $tmux_session${NC}"
        echo ""
        echo -e "Or if not in tmux:"
        echo -e "  ${YELLOW}tmux attach -t $tmux_session${NC}"
        exit 0
    fi

    # Read port from existing .env if available (may already be set from branch-creation path)
    if [[ -z "${server_url:-}" ]]; then
        local rails_port=""
        local server_url=""
        if [[ -f "$workspace_dir/.env" ]]; then
            local vite_port
            vite_port=$(grep '^VITE_RUBY_PORT=' "$workspace_dir/.env" | cut -d= -f2 | tr -d '"' || true)
            if [[ -n "$vite_port" ]]; then
                rails_port=$((vite_port + 2))
                server_url="http://localhost:$rails_port"
            fi
        fi
    fi

    echo -e "${GREEN}Resuming workspace: $feature${NC}"
    echo -e "  Project:             $project"
    echo -e "  Workspace directory: $workspace_dir"
    if [[ -n "$server_url" ]]; then
        echo -e "  Server URL:          $server_url"
    fi
    echo ""

    # Create tmux session
    echo -e "${YELLOW}Creating tmux session: $tmux_session${NC}"

    # Create tmux session with first window for coding
    tmux new-session -d -s "$tmux_session" -c "$workspace_dir" -n "code"

    # Open the feature's own docs file if it exists
    local docs_file=""
    if [[ -f "$workspace_dir/docs/$feature.md" ]]; then
        docs_file="$workspace_dir/docs/$feature.md"
    fi

    if [[ -n "$docs_file" ]]; then
        tmux send-keys -t "$tmux_session:code" "vim \"$docs_file\"" C-m
    else
        tmux send-keys -t "$tmux_session:code" "vim" C-m
    fi

    # Split first window vertically: vim on left, shell on right
    tmux split-window -h -t "$tmux_session:code" -c "$workspace_dir"

    # Create banner file and display in shell pane
    cat > "$workspace_dir/.banner" << EOF

   ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
   ┃  Project: $project
   ┃  Feature: $feature
   ┃  Server:  ${server_url:-"(unknown)"}
   ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

EOF
    tmux send-keys -t "$tmux_session:code.1" "clear && cat .banner" C-m

    # Create second window for server
    tmux new-window -t "$tmux_session" -c "$workspace_dir" -n "server"

    # Create a setup script that runs in the server window
    cat > "$workspace_dir/.workspace-setup.sh" << 'SETUP_SCRIPT'
#!/usr/bin/env bash
set -e

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

echo -e "${YELLOW}Setting up node version...${NC}"
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"
nvm use

echo -e "${YELLOW}Installing dependencies...${NC}"
echo -e "  Running bundle install..."
if ! bundle install; then
    echo -e "${RED}bundle install failed${NC}"
    exit 1
fi

echo -e "  Running yarn install..."
if ! yarn install; then
    echo -e "${RED}yarn install failed${NC}"
    exit 1
fi

echo ""
echo -e "${GREEN}Setup complete!${NC}"
echo ""
SETUP_SCRIPT

    # Append the server start to the setup script
    cat >> "$workspace_dir/.workspace-setup.sh" << EOF
echo ""
echo -e "${GREEN}Starting overmind...${NC}"
echo ""
rm -f "\$0"  # Clean up this script
exec overmind start -f Procfile.workspace
EOF

    chmod +x "$workspace_dir/.workspace-setup.sh"

    # Run the setup script in the server window
    tmux send-keys -t "$tmux_session:server" "./.workspace-setup.sh" C-m

    # Go back to first window, focus on vim pane
    tmux select-window -t "$tmux_session:code"
    tmux select-pane -t "$tmux_session:code.0"

    echo ""
    echo -e "${GREEN}Workspace resumed!${NC}"
    echo ""
    echo -e "  Tmux session: ${YELLOW}$tmux_session${NC}"
    if [[ -n "$server_url" ]]; then
        echo -e "  Server URL:   ${YELLOW}$server_url${NC}"
    fi
    echo ""
    echo -e "Switch to session:"
    echo -e "  ${YELLOW}tmux switch-client -t $tmux_session${NC}"
    echo ""
    echo -e "Or if not in tmux:"
    echo -e "  ${YELLOW}tmux attach -t $tmux_session${NC}"
}

# ============================================================================
# Claude session consolidation
# ============================================================================

# Move Claude Code conversation files from a worktree's project dir into the
# main repo's project dir so they appear in `claude resume` from the main repo.
consolidate_claude_sessions() {
    local worktree_path="$1"
    local main_repo_path="$2"

    # Encode paths the way Claude Code does: replace / with - and prepend -
    local worktree_encoded="${worktree_path//\//-}"
    local main_encoded="${main_repo_path//\//-}"

    local src="$HOME/.claude/projects/$worktree_encoded"
    local dst="$HOME/.claude/projects/$main_encoded"

    if [[ ! -d "$src" ]]; then
        return
    fi

    mkdir -p "$dst"

    local moved=0
    for jsonl in "$src"/*.jsonl; do
        [[ -f "$jsonl" ]] || continue
        local uuid
        uuid=$(basename "$jsonl" .jsonl)
        mv "$jsonl" "$dst/"
        [[ -d "$src/$uuid" ]] && mv "$src/$uuid" "$dst/"
        moved=$((moved + 1))
    done

    # Clean up the now-empty project dir (memory/ and anything else)
    rm -rf "$src"

    if [[ $moved -gt 0 ]]; then
        echo -e "${BLUE}Moved $moved Claude session(s) to main project${NC}"
    fi
}

# ============================================================================
# Subcommand: delete
# ============================================================================

cmd_delete() {
    local project="$1"
    local feature="$2"
    local force=false

    # Check for --force flag
    if [[ "$3" == "--force" ]]; then
        force=true
    fi

    if [[ -z "$project" ]] || [[ -z "$feature" ]]; then
        echo "Usage: workspace delete <project> <feature> [--force]"
        echo ""
        echo "Example: workspace delete tract my-feature"
        exit 1
    fi

    validate_project "$project"
    get_project_paths "$project"

    local workspace_dir
    workspace_dir=$(resolve_worktree_path "$project" "$feature")
    if [[ -z "$workspace_dir" ]]; then
        echo -e "${RED}Error: No worktree found for '$feature'${NC}"
        echo ""
        echo "Current worktrees for $project:"
        git -C "$PROJECT_PATH" worktree list
        exit 1
    fi

    # Capture the actual branch name from the worktree before we remove it
    local worktree_branch
    worktree_branch=$(git -C "$PROJECT_PATH" worktree list | awk -v dir="$workspace_dir " '$0 ~ dir {gsub(/[\[\]]/, "", $3); print $3; exit}')
    local tmux_session="${project}-${worktree_branch}"

    # Prevent deleting the main directory
    if [[ "$workspace_dir" == "$PROJECT_PATH" ]]; then
        echo -e "${RED}Error: Cannot delete the main workspace${NC}"
        exit 1
    fi

    echo -e "${YELLOW}Workspace to delete: $feature${NC}"
    echo -e "  Project:   $project"
    echo -e "  Directory: $workspace_dir"
    echo ""

    # Kill tmux session if it exists
    if tmux has-session -t "$tmux_session" 2>/dev/null; then
        echo -e "${YELLOW}Killing tmux session: $tmux_session${NC}"
        tmux kill-session -t "$tmux_session"
    fi

    # Kill any overmind processes in that directory
    if [[ -f "$workspace_dir/.overmind.sock" ]]; then
        echo -e "${YELLOW}Stopping overmind...${NC}"
        (cd "$workspace_dir" && overmind quit 2>/dev/null) || true
    fi

    # Confirm deletion
    if [[ "$force" != true ]]; then
        read -p "Delete worktree at $workspace_dir? [y/N] " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Cancelled."
            exit 0
        fi
    fi

    # Remove the worktree
    echo -e "${YELLOW}Removing git worktree...${NC}"
    cd "$PROJECT_PATH"
    if ! git worktree remove "$workspace_dir" --force 2>/dev/null; then
        echo -e "${YELLOW}Worktree has untracked files, cleaning up manually...${NC}"
        rm -rf "$workspace_dir"
        git worktree prune
    fi

    # Move Claude Code sessions from the worktree to the main project
    consolidate_claude_sessions "$workspace_dir" "$PROJECT_PATH"

    # Ask about deleting the branch
    if [[ -n "$worktree_branch" ]]; then
        local branch_exists
        branch_exists=$(git branch --list "$worktree_branch")
        if [[ -n "$branch_exists" ]]; then
            local delete_branch
            if [[ "$force" == true ]]; then
                delete_branch="y"
            else
                read -p "Delete branch '$worktree_branch'? [y/N] " -n 1 -r delete_branch
                echo
            fi

            if [[ $delete_branch =~ ^[Yy]$ ]]; then
                echo -e "${YELLOW}Deleting branch: $worktree_branch${NC}"
                git branch -D "$worktree_branch"
            else
                echo -e "Branch '$worktree_branch' kept. Delete it later with: git branch -D $worktree_branch"
            fi
        fi
    fi

    echo ""
    echo -e "${GREEN}Workspace deleted successfully!${NC}"
}

# ============================================================================
# Subcommand: list
# ============================================================================

cmd_list() {
    local filter_project="$1"

    if [[ -n "$filter_project" ]]; then
        validate_project "$filter_project"
    fi

    local projects
    if [[ -n "$filter_project" ]]; then
        projects="$filter_project"
    else
        projects=$(list_projects)
    fi

    local rows=""

    for project in $projects; do
        get_project_paths "$project"

        # Get worktrees for this project
        local worktrees
        worktrees=$(git -C "$PROJECT_PATH" worktree list 2>/dev/null || true)

        if [[ -z "$worktrees" ]]; then
            continue
        fi

        # Filter out the main project path, only show actual worktrees
        local workspace_worktrees
        workspace_worktrees=$(echo "$worktrees" | grep -v "^$PROJECT_PATH " || true)

        [[ -z "$workspace_worktrees" ]] && continue

        local origin_url=""
        if command -v gh &>/dev/null; then
            origin_url=$(git -C "$PROJECT_PATH" remote get-url origin 2>/dev/null || true)
        fi

        while IFS= read -r line; do
            local path branch
            path=$(echo "$line" | awk '{print $1}')
            branch=$(echo "$line" | awk '{print $3}' | tr -d '[]')

            # Extract feature name from path
            local feature
            feature=$(basename "$path")

            # Check if tmux session exists
            local tmux_session="${project}-${branch}"
            local tmux_status=""
            if tmux has-session -t "$tmux_session" 2>/dev/null; then
                tmux_status="running"
            fi

            # Check PR status via GitHub CLI
            local pr_status=""
            if [[ -n "$origin_url" ]]; then
                local pr_state pr_url
                pr_state=$(gh pr view "$branch" --repo "$origin_url" --json state --jq '.state' 2>/dev/null || true)
                pr_url=$(gh pr view "$branch" --repo "$origin_url" --json url --jq '.url' 2>/dev/null || true)
                case "$pr_state" in
                    OPEN)   pr_status="open" ;;
                    MERGED) pr_status="merged" ;;
                    CLOSED) pr_status="closed" ;;
                esac

                # Add PR URL to docs file if missing
                local docs_file="$path/docs/${feature}.md"
                if [[ -n "$pr_url" && -f "$docs_file" ]] && ! grep -q "^PR:" "$docs_file"; then
                    sed -i '' "/^Path:/s|$|\nPR:          $pr_url|" "$docs_file"
                fi
            fi

            # Pad tmux/pr values so column alignment uses consistent width
            local tmux_display="${tmux_status:-~}"
            local pr_display="${pr_status:-~}"
            rows+="$project,$feature,$branch,$tmux_display,$pr_display"$'\n'
        done <<< "$workspace_worktrees"
    done

    if [[ -z "$rows" ]]; then
        if [[ -n "$filter_project" ]]; then
            echo "No workspaces found for project: $filter_project"
        else
            echo "No workspaces found."
        fi
        return
    fi

    local table header_line separator max_width
    table=$(printf "Project,Workspace,Branch,Tmux,PR\n%s" "$rows" | column -t -s,)
    header_line=$(echo "$table" | head -1)
    max_width=$(echo "$table" | awk '{ if (length > max) max = length } END { print max }')
    separator=$(printf '%*s' "$max_width" '' | tr ' ' '-')

    # Replace placeholders and render table
    local body
    body=$(echo "$table" | tail -n +2 | sed 's/~/ /g')
    table=$(printf "%s\n%s\n%s" "$header_line" "$separator" "$body")
    echo "$table" | gum style \
        --border rounded \
        --border-foreground "#7D56F4" \
        --padding "0 1"
}

cmd_ports() {
    local projects
    projects=$(list_projects)

    local rows=""

    for project in $projects; do
        get_project_paths "$project"

        local worktrees
        worktrees=$(git -C "$PROJECT_PATH" worktree list 2>/dev/null || true)
        [[ -z "$worktrees" ]] && continue

        # Skip the main project path
        local workspace_worktrees
        workspace_worktrees=$(echo "$worktrees" | grep -v "^$PROJECT_PATH " || true)
        [[ -z "$workspace_worktrees" ]] && continue

        while IFS= read -r line; do
            local path
            path=$(echo "$line" | awk '{print $1}')
            [[ -f "$path/.env" ]] || continue

            local vite_port rails_port db
            vite_port=$(grep '^VITE_RUBY_PORT=' "$path/.env" | cut -d= -f2 | tr -d '"' || true)
            db=$(grep '^REDIS_URL=' "$path/.env" | sed 's|.*redis://[^/]*/||' | tr -d '"' || true)

            [[ -z "$vite_port" && -z "$db" ]] && continue

            rails_port=""
            if [[ -n "$vite_port" ]]; then
                rails_port=$((vite_port + 2))
            fi

            local feature
            feature=$(basename "$path")

            rows+="$project,$feature,$rails_port,$vite_port,$db"$'\n'
        done <<< "$workspace_worktrees"
    done

    if [[ -z "$rows" ]]; then
        echo "No workspaces found."
        return
    fi

    local table header_line separator max_width
    table=$(printf "Project,Workspace,Rails,Vite,Redis\n%s" "$rows" | column -t -s,)
    header_line=$(echo "$table" | head -1)
    max_width=$(echo "$table" | awk '{ if (length > max) max = length } END { print max }')
    separator=$(printf '%*s' "$max_width" '' | tr ' ' '-')
    table=$(printf "%s\n%s\n%s" "$header_line" "$separator" "$(echo "$table" | tail -n +2)")
    echo "$table" | gum style \
        --border rounded \
        --border-foreground "#7D56F4" \
        --padding "0 1"
}

# ============================================================================
# Resume all workspaces
# ============================================================================

cmd_resume_all() {
    local projects
    projects=$(list_projects)

    local to_resume=()
    local already_running=()

    for project in $projects; do
        get_project_paths "$project"

        local worktrees
        worktrees=$(git -C "$PROJECT_PATH" worktree list 2>/dev/null || true)
        [[ -z "$worktrees" ]] && continue

        local workspace_worktrees
        workspace_worktrees=$(echo "$worktrees" | grep -v "^$PROJECT_PATH " || true)
        [[ -z "$workspace_worktrees" ]] && continue

        while IFS= read -r line; do
            local path branch
            path=$(echo "$line" | awk '{print $1}')
            branch=$(echo "$line" | awk '{print $3}' | tr -d '[]')

            local feature
            feature=$(basename "$path")

            local tmux_session="${project}-${branch}"
            if tmux has-session -t "$tmux_session" 2>/dev/null; then
                already_running+=("$project/$feature")
            else
                to_resume+=("$project $feature")
            fi
        done <<< "$workspace_worktrees"
    done

    if [[ ${#to_resume[@]} -eq 0 && ${#already_running[@]} -eq 0 ]]; then
        echo "No workspaces found."
        return
    fi

    if [[ ${#already_running[@]} -gt 0 ]]; then
        echo -e "${BLUE}Already running:${NC}"
        for item in "${already_running[@]}"; do
            echo -e "  $item"
        done
        echo ""
    fi

    if [[ ${#to_resume[@]} -eq 0 ]]; then
        echo "All workspaces are already running."
        return
    fi

    echo -e "${GREEN}Resuming ${#to_resume[@]} workspace(s)...${NC}"
    echo ""

    local resumed=0
    for item in "${to_resume[@]}"; do
        local project feature
        project=$(echo "$item" | awk '{print $1}')
        feature=$(echo "$item" | awk '{print $2}')

        echo -e "${CYAN}━━━ $project / $feature ━━━${NC}"
        cmd_resume "$project" "$feature"
        resumed=$((resumed + 1))
        echo ""
    done

    echo -e "${GREEN}Done! Resumed $resumed workspace(s).${NC}"
}

# ============================================================================
# Main
# ============================================================================

usage() {
    echo "Usage: workspace <command> [args]"
    echo ""
    echo "Commands:"
    echo "  new <project> <feature>      Create a new workspace (new branch off master)"
    echo "  pull <project> <branch>      Pull a remote branch into a new workspace"
    echo "  resume <project> <feature>   Resume an existing workspace (creates worktree from branch if needed)"
    echo "  resume-all                   Resume all workspaces (useful after reboot)"
    echo "  delete <project> <feature>   Delete a workspace"
    echo "  list [project]               List all workspaces"
    echo "  ports                        Show all port and Redis allocations"
    echo ""
    echo "Examples:"
    echo "  workspace new tract my-feature"
    echo "  workspace pull tract remote-branch"
    echo "  workspace resume tract my-feature"
    echo "  workspace delete tract my-feature"
    echo "  workspace list"
    echo "  workspace list tract"
    echo ""
    echo "Config file: $CONFIG_FILE"
}

main() {
    local command="$1"
    shift || true

    case "$command" in
        new)
            check_config
            cmd_new "$@"
            ;;
        pull)
            check_config
            cmd_pull "$@"
            ;;
        resume)
            check_config
            cmd_resume "$@"
            ;;
        resume-all)
            check_config
            cmd_resume_all
            ;;
        delete)
            check_config
            cmd_delete "$@"
            ;;
        list)
            check_config
            cmd_list "$@"
            ;;
        ports|redis)
            check_config
            cmd_ports
            ;;
        -h|--help|"")
            usage
            ;;
        *)
            echo -e "${RED}Unknown command: $command${NC}"
            echo ""
            usage
            exit 1
            ;;
    esac
}

main "$@"
