#!/usr/bin/env bash
set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

CONFIG_FILE="$HOME/.workspaces.yml"

# ============================================================================
# Config parsing functions
# ============================================================================

check_config() {
    if [[ ! -f "$CONFIG_FILE" ]]; then
        echo -e "${RED}Error: Config file not found at $CONFIG_FILE${NC}"
        echo ""
        echo "Create it with the following format:"
        echo ""
        echo "projects:"
        echo "  myproject:"
        echo "    path: ~/projects/myproject/app"
        echo "    worktree_dir: ~/projects/myproject"
        exit 1
    fi
}

# Simple YAML parser for our specific format
# Gets a project's path or worktree_dir
get_project_config() {
    local project="$1"
    local key="$2"

    # Parse the YAML file to find the project section and extract the key
    awk -v proj="$project" -v key="$key" '
        /^  [a-zA-Z_-]+:$/ {
            current_project = $1
            gsub(/:$/, "", current_project)
        }
        current_project == proj && $1 == key":" {
            # Get value after the key, trim whitespace and comments
            val = $0
            sub(/^[^:]+:[ \t]*/, "", val)
            sub(/[ \t]*#.*$/, "", val)
            print val
            exit
        }
    ' "$CONFIG_FILE"
}

# Expand ~ to $HOME
expand_path() {
    local path="$1"
    echo "${path/#\~/$HOME}"
}

# List all configured projects
list_projects() {
    awk '/^  [a-zA-Z_-]+:$/ {
        proj = $1
        gsub(/:$/, "", proj)
        print proj
    }' "$CONFIG_FILE"
}

# Validate project exists in config
validate_project() {
    local project="$1"
    local projects
    projects=$(list_projects)

    if ! echo "$projects" | grep -qx "$project"; then
        echo -e "${RED}Error: Unknown project '$project'${NC}"
        echo ""
        echo "Available projects:"
        echo "$projects" | sed 's/^/  /'
        exit 1
    fi
}

# Get project paths
get_project_paths() {
    local project="$1"

    PROJECT_PATH=$(expand_path "$(get_project_config "$project" "path")")
    WORKTREE_DIR=$(expand_path "$(get_project_config "$project" "worktree_dir")")

    if [[ -z "$PROJECT_PATH" ]] || [[ -z "$WORKTREE_DIR" ]]; then
        echo -e "${RED}Error: Project '$project' is missing path or worktree_dir in config${NC}"
        exit 1
    fi

    if [[ ! -d "$PROJECT_PATH" ]]; then
        echo -e "${RED}Error: Project path does not exist: $PROJECT_PATH${NC}"
        exit 1
    fi
}

# Sanitize a branch/feature name for use as a directory name (replace / with -)
sanitize_dir_name() {
    echo "${1//\//-}"
}

# Find the next available Redis DB number (1-15) by scanning ALL projects' worktrees
next_free_redis_db() {
    local used_dbs=""

    # Scan worktrees across all configured projects (they share the same Redis)
    for project in $(list_projects); do
        local proj_path
        proj_path=$(expand_path "$(get_project_config "$project" "path")")
        [[ -d "$proj_path" ]] || continue

        while IFS= read -r line; do
            local wt_path
            wt_path=$(echo "$line" | awk '{print $1}')
            if [[ -f "$wt_path/.env" ]]; then
                local db
                db=$(grep '^REDIS_URL=' "$wt_path/.env" | sed 's|.*redis://[^/]*/||' | tr -d '"' || true)
                if [[ -n "$db" ]]; then
                    used_dbs="$used_dbs $db"
                fi
            fi
        done <<< "$(git -C "$proj_path" worktree list 2>/dev/null)"
    done

    for db in $(seq 1 15); do
        if ! echo "$used_dbs" | grep -qw "$db"; then
            echo "$db"
            return
        fi
    done

    echo -e "${RED}Warning: All Redis DBs (1-15) are in use${NC}" >&2
    echo "1"
}

# Resolve the actual worktree path for a feature.
# If the config-derived path isn't a worktree, search git worktree list by branch name.
resolve_worktree_path() {
    local project="$1"
    local feature="$2"
    local config_dir="$WORKTREE_DIR/$(sanitize_dir_name "$feature")"

    # Check if the config-derived path is a known worktree
    if git -C "$PROJECT_PATH" worktree list | grep -q "^$config_dir "; then
        echo "$config_dir"
        return
    fi

    # Fall back: search by directory name or branch name
    local found_path
    found_path=$(git -C "$PROJECT_PATH" worktree list | awk -v feat="/$feature " -v branch="[$feature]" '$0 ~ feat || $3 == branch {print $1; exit}')

    if [[ -n "$found_path" ]]; then
        echo "$found_path"
        return
    fi

    # Nothing found
    echo ""
}

# ============================================================================
# Subcommand: new
# ============================================================================

cmd_new() {
    local project="$1"
    local feature="$2"

    if [[ -z "$project" ]] || [[ -z "$feature" ]]; then
        echo "Usage: workspace new <project> <feature>"
        echo ""
        echo "Example: workspace new tract my-feature"
        exit 1
    fi

    validate_project "$project"
    get_project_paths "$project"

    local workspace_dir="$WORKTREE_DIR/$(sanitize_dir_name "$feature")"

    # Check if directory already exists
    if [[ -d "$workspace_dir" ]]; then
        echo -e "${RED}Error: Directory $workspace_dir already exists${NC}"
        exit 1
    fi

    # Generate a random port between 3100-3900 (avoiding common ports)
    local random_port=$((3100 + RANDOM % 800))
    local rails_port=$((random_port + 2))
    local server_url="http://localhost:$rails_port"
    local session_cookie="${project}_cookie_${rails_port}"
    local redis_db
    redis_db=$(next_free_redis_db)

    echo -e "${GREEN}Creating new workspace: $feature${NC}"
    echo -e "  Project:             $project"
    echo -e "  Workspace directory: $workspace_dir"
    echo -e "  Vite port:           $random_port"
    echo -e "  Rails port:          $rails_port"
    echo -e "  Session cookie:      $session_cookie"
    echo -e "  Redis DB:            $redis_db"
    echo ""

    # Fetch latest from origin
    echo -e "${YELLOW}Fetching latest from origin...${NC}"
    git -C "$PROJECT_PATH" fetch origin master

    # Create new worktree with a new branch
    echo -e "${YELLOW}Creating git worktree...${NC}"
    git -C "$PROJECT_PATH" worktree add -b "$feature" "$workspace_dir" origin/master

    # Copy .env file if it exists in main workspace
    if [[ -f "$PROJECT_PATH/.env" ]]; then
        echo -e "${YELLOW}Copying .env file...${NC}"
        cp "$PROJECT_PATH/.env" "$workspace_dir/.env"
    fi

    # Update .env file with workspace-specific settings
    echo -e "${YELLOW}Configuring .env...${NC}"

    # Remove existing workspace-specific vars if present
    if [[ -f "$workspace_dir/.env" ]]; then
        grep -v '^SESSION_COOKIE_NAME=' "$workspace_dir/.env" | grep -v '^VITE_RUBY_PORT=' | grep -v '^REDIS_URL=' > "$workspace_dir/.env.tmp" || true
        mv "$workspace_dir/.env.tmp" "$workspace_dir/.env"
    fi

    # Append workspace-specific settings
    cat >> "$workspace_dir/.env" << EOF

# Workspace-specific settings (port: $random_port)
SESSION_COOKIE_NAME="$session_cookie"
VITE_RUBY_PORT=$random_port
REDIS_URL=redis://localhost:6379/$redis_db
EOF

    # Create .env.test to force Vite to compile instead of proxying to dev server
    cat > "$workspace_dir/.env.test" << EOF
VITE_RUBY_PORT=3037
EOF

    # Create a workspace-specific Procfile
    echo -e "${YELLOW}Creating Procfile.workspace...${NC}"
    local template_file="$PROJECT_PATH/Procfile.workspace.template"

    if [[ -f "$template_file" ]]; then
        # Use project-specific template with variable substitution
        sed -e "s/\$RAILS_PORT/$rails_port/g" \
            -e "s/\$VITE_PORT/$random_port/g" \
            "$template_file" > "$workspace_dir/Procfile.workspace"
    else
        # Default Rails Procfile
        cat > "$workspace_dir/Procfile.workspace" << EOF
web: RUBY_DEBUG_OPEN=true bin/rails server -p $rails_port
vite: VITE_RUBY_PORT=$random_port bin/vite dev
worker: RUBY_DEBUG_OPEN=true bundle exec sidekiq -C config/sidekiq.yml
EOF
    fi

    # Create tmux session
    local tmux_session="${project}-${feature}"
    echo -e "${YELLOW}Creating tmux session: $tmux_session${NC}"

    # Create docs directory and feature notes file
    mkdir -p "$workspace_dir/docs"
    cat > "$workspace_dir/docs/$feature.md" << EOF
# New Feature - $feature

---
Server URL:  $server_url
Git branch:  $feature
Path:        $workspace_dir
---

Start describing your new feature...
EOF

    # Create tmux session with first window for coding
    tmux new-session -d -s "$tmux_session" -c "$workspace_dir" -n "code"

    # Split first window vertically: vim on left, shell on right
    tmux send-keys -t "$tmux_session:code" "vim docs/$feature.md" C-m
    tmux split-window -h -t "$tmux_session:code" -c "$workspace_dir"

    # Create banner file and display in shell pane
    cat > "$workspace_dir/.banner" << EOF

   ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
   ┃  Project: $project
   ┃  Feature: $feature
   ┃  Server:  $server_url
   ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

EOF
    tmux send-keys -t "$tmux_session:code.1" "clear && cat .banner" C-m

    # Create second window for server
    tmux new-window -t "$tmux_session" -c "$workspace_dir" -n "server"

    # Create a setup script that runs in the server window
    cat > "$workspace_dir/.workspace-setup.sh" << 'SETUP_SCRIPT'
#!/usr/bin/env bash
set -e

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

echo -e "${YELLOW}Setting up node version...${NC}"
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"
nvm use

echo -e "${YELLOW}Installing dependencies...${NC}"
echo -e "  Running bundle install..."
if ! bundle install; then
    echo -e "${RED}bundle install failed${NC}"
    exit 1
fi

echo -e "  Running yarn install..."
if ! yarn install; then
    echo -e "${RED}yarn install failed${NC}"
    exit 1
fi

echo ""
echo -e "${GREEN}Setup complete!${NC}"
echo ""
SETUP_SCRIPT

    # Append the server start to the setup script
    cat >> "$workspace_dir/.workspace-setup.sh" << EOF
echo ""
echo -e "${GREEN}Starting overmind...${NC}"
echo ""
rm -f "\$0"  # Clean up this script
exec overmind start -f Procfile.workspace
EOF

    chmod +x "$workspace_dir/.workspace-setup.sh"

    # Run the setup script in the server window
    tmux send-keys -t "$tmux_session:server" "./.workspace-setup.sh" C-m

    # Go back to first window, focus on vim pane
    tmux select-window -t "$tmux_session:code"
    tmux select-pane -t "$tmux_session:code.0"

    echo ""
    echo -e "${GREEN}Workspace created!${NC}"
    echo ""
    echo -e "  Tmux session: ${YELLOW}$tmux_session${NC}"
    echo -e "  Server URL:   ${YELLOW}$server_url${NC}"
    echo ""
    echo -e "Switch to session:"
    echo -e "  ${YELLOW}tmux switch-client -t $tmux_session${NC}"
    echo ""
    echo -e "Or if not in tmux:"
    echo -e "  ${YELLOW}tmux attach -t $tmux_session${NC}"
    echo ""
    echo -e "To delete this workspace later:"
    echo -e "  ${YELLOW}workspace delete $project $feature${NC}"
}

# ============================================================================
# Subcommand: pull
# ============================================================================

cmd_pull() {
    local project="$1"
    local branch="$2"

    if [[ -z "$project" ]] || [[ -z "$branch" ]]; then
        echo "Usage: workspace pull <project> <branch>"
        echo ""
        echo "Example: workspace pull tract remote-branch"
        exit 1
    fi

    validate_project "$project"
    get_project_paths "$project"

    local workspace_dir="$WORKTREE_DIR/$(sanitize_dir_name "$branch")"

    # Check if directory already exists
    if [[ -d "$workspace_dir" ]]; then
        echo -e "${RED}Error: Directory $workspace_dir already exists${NC}"
        exit 1
    fi

    # Generate a random port between 3100-3900 (avoiding common ports)
    local random_port=$((3100 + RANDOM % 800))
    local rails_port=$((random_port + 2))
    local server_url="http://localhost:$rails_port"
    local session_cookie="${project}_cookie_${rails_port}"

    local redis_db
    redis_db=$(next_free_redis_db)

    echo -e "${GREEN}Pulling remote branch: $branch${NC}"
    echo -e "  Project:             $project"
    echo -e "  Workspace directory: $workspace_dir"
    echo -e "  Vite port:           $random_port"
    echo -e "  Rails port:          $rails_port"
    echo -e "  Session cookie:      $session_cookie"
    echo -e "  Redis DB:            $redis_db"
    echo ""

    # Fetch the remote branch
    echo -e "${YELLOW}Fetching branch from origin...${NC}"
    git -C "$PROJECT_PATH" fetch origin "$branch"

    # Create worktree tracking the remote branch
    echo -e "${YELLOW}Creating git worktree...${NC}"
    git -C "$PROJECT_PATH" worktree add --track -b "$branch" "$workspace_dir" "origin/$branch"

    # Copy .env file if it exists in main workspace
    if [[ -f "$PROJECT_PATH/.env" ]]; then
        echo -e "${YELLOW}Copying .env file...${NC}"
        cp "$PROJECT_PATH/.env" "$workspace_dir/.env"
    fi

    # Update .env file with workspace-specific settings
    echo -e "${YELLOW}Configuring .env...${NC}"

    # Remove existing workspace-specific vars if present
    if [[ -f "$workspace_dir/.env" ]]; then
        grep -v '^SESSION_COOKIE_NAME=' "$workspace_dir/.env" | grep -v '^VITE_RUBY_PORT=' | grep -v '^REDIS_URL=' > "$workspace_dir/.env.tmp" || true
        mv "$workspace_dir/.env.tmp" "$workspace_dir/.env"
    fi

    # Append workspace-specific settings
    cat >> "$workspace_dir/.env" << EOF

# Workspace-specific settings (port: $random_port)
SESSION_COOKIE_NAME="$session_cookie"
VITE_RUBY_PORT=$random_port
REDIS_URL=redis://localhost:6379/$redis_db
EOF

    # Create .env.test to force Vite to compile instead of proxying to dev server
    cat > "$workspace_dir/.env.test" << EOF
VITE_RUBY_PORT=3037
EOF

    # Create a workspace-specific Procfile
    echo -e "${YELLOW}Creating Procfile.workspace...${NC}"
    local template_file="$PROJECT_PATH/Procfile.workspace.template"

    if [[ -f "$template_file" ]]; then
        # Use project-specific template with variable substitution
        sed -e "s/\$RAILS_PORT/$rails_port/g" \
            -e "s/\$VITE_PORT/$random_port/g" \
            "$template_file" > "$workspace_dir/Procfile.workspace"
    else
        # Default Rails Procfile
        cat > "$workspace_dir/Procfile.workspace" << EOF
web: RUBY_DEBUG_OPEN=true bin/rails server -p $rails_port
vite: VITE_RUBY_PORT=$random_port bin/vite dev
worker: RUBY_DEBUG_OPEN=true bundle exec sidekiq -C config/sidekiq.yml
EOF
    fi

    # Create tmux session
    local tmux_session="${project}-${branch}"
    echo -e "${YELLOW}Creating tmux session: $tmux_session${NC}"

    # Create docs directory and feature notes file
    local notes_file="$workspace_dir/docs/$branch.md"
    mkdir -p "$(dirname "$notes_file")"

    # Try to fetch PR description from GitHub
    echo -e "${YELLOW}Fetching PR description from GitHub...${NC}"
    local pr_description=""
    local pr_title=""
    local pr_url=""

    # Get PR info for this branch (using gh CLI)
    if command -v gh &> /dev/null; then
        pr_url=$(gh pr view "$branch" --repo "$(git -C "$PROJECT_PATH" remote get-url origin)" --json url --jq '.url' 2>/dev/null || true)
        pr_title=$(gh pr view "$branch" --repo "$(git -C "$PROJECT_PATH" remote get-url origin)" --json title --jq '.title' 2>/dev/null || true)
        pr_description=$(gh pr view "$branch" --repo "$(git -C "$PROJECT_PATH" remote get-url origin)" --json body --jq '.body' 2>/dev/null || true)
    fi

    if [[ -n "$pr_title" ]]; then
        echo -e "  Found PR: ${CYAN}$pr_title${NC}"
        cat > "$notes_file" << EOF
# $pr_title

---
Server URL:  $server_url
Git branch:  $branch
Path:        $workspace_dir
PR:          $pr_url
---

## PR Description

$pr_description
EOF
    else
        echo -e "  ${YELLOW}No PR found for branch, creating basic notes file${NC}"
        cat > "$notes_file" << EOF
# $branch

---
Server URL:  $server_url
Git branch:  $branch
Path:        $workspace_dir
---

No PR found for this branch.
EOF
    fi

    # Create tmux session with first window for coding
    tmux new-session -d -s "$tmux_session" -c "$workspace_dir" -n "code"

    # Split first window vertically: vim on left, shell on right
    tmux send-keys -t "$tmux_session:code" "vim \"$notes_file\"" C-m
    tmux split-window -h -t "$tmux_session:code" -c "$workspace_dir"

    # Create banner file and display in shell pane
    cat > "$workspace_dir/.banner" << EOF

   ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
   ┃  Project: $project
   ┃  Branch:  $branch
   ┃  Server:  $server_url
   ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

EOF
    tmux send-keys -t "$tmux_session:code.1" "clear && cat .banner" C-m

    # Create second window for server
    tmux new-window -t "$tmux_session" -c "$workspace_dir" -n "server"

    # Create a setup script that runs in the server window
    cat > "$workspace_dir/.workspace-setup.sh" << 'SETUP_SCRIPT'
#!/usr/bin/env bash
set -e

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

echo -e "${YELLOW}Setting up node version...${NC}"
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"
nvm use

echo -e "${YELLOW}Installing dependencies...${NC}"
echo -e "  Running bundle install..."
if ! bundle install; then
    echo -e "${RED}bundle install failed${NC}"
    exit 1
fi

echo -e "  Running yarn install..."
if ! yarn install; then
    echo -e "${RED}yarn install failed${NC}"
    exit 1
fi

echo ""
echo -e "${GREEN}Setup complete!${NC}"
echo ""
SETUP_SCRIPT

    # Append the server start to the setup script
    cat >> "$workspace_dir/.workspace-setup.sh" << EOF
echo ""
echo -e "${GREEN}Starting overmind...${NC}"
echo ""
rm -f "\$0"  # Clean up this script
exec overmind start -f Procfile.workspace
EOF

    chmod +x "$workspace_dir/.workspace-setup.sh"

    # Run the setup script in the server window
    tmux send-keys -t "$tmux_session:server" "./.workspace-setup.sh" C-m

    # Go back to first window, focus on vim pane
    tmux select-window -t "$tmux_session:code"
    tmux select-pane -t "$tmux_session:code.0"

    echo ""
    echo -e "${GREEN}Workspace created from remote branch!${NC}"
    echo ""
    echo -e "  Tmux session: ${YELLOW}$tmux_session${NC}"
    echo -e "  Server URL:   ${YELLOW}$server_url${NC}"
    echo ""
    echo -e "Switch to session:"
    echo -e "  ${YELLOW}tmux switch-client -t $tmux_session${NC}"
    echo ""
    echo -e "Or if not in tmux:"
    echo -e "  ${YELLOW}tmux attach -t $tmux_session${NC}"
    echo ""
    echo -e "To delete this workspace later:"
    echo -e "  ${YELLOW}workspace delete $project $branch${NC}"
}

# ============================================================================
# Subcommand: resume
# ============================================================================

cmd_resume() {
    local project="$1"
    local feature="$2"

    if [[ -z "$project" ]] || [[ -z "$feature" ]]; then
        echo "Usage: workspace resume <project> <feature>"
        echo ""
        echo "Example: workspace resume tract my-feature"
        exit 1
    fi

    validate_project "$project"
    get_project_paths "$project"

    local workspace_dir
    workspace_dir=$(resolve_worktree_path "$project" "$feature")
    local tmux_session="${project}-${feature}"

    if [[ -z "$workspace_dir" ]]; then
        echo -e "${RED}Error: No worktree found for '$feature'${NC}"
        echo ""
        echo "Use 'workspace new' or 'workspace pull' to create a workspace first."
        exit 1
    fi

    # Check if workspace exists on disk
    if [[ ! -d "$workspace_dir" ]]; then
        echo -e "${RED}Error: Workspace directory does not exist: $workspace_dir${NC}"
        exit 1
    fi

    # Check if tmux session already exists
    if tmux has-session -t "$tmux_session" 2>/dev/null; then
        echo -e "${YELLOW}Tmux session '$tmux_session' already exists${NC}"
        echo ""
        echo -e "Switch to session:"
        echo -e "  ${YELLOW}tmux switch-client -t $tmux_session${NC}"
        echo ""
        echo -e "Or if not in tmux:"
        echo -e "  ${YELLOW}tmux attach -t $tmux_session${NC}"
        exit 0
    fi

    # Read port from existing .env if available
    local rails_port=""
    local server_url=""
    if [[ -f "$workspace_dir/.env" ]]; then
        local vite_port
        vite_port=$(grep '^VITE_RUBY_PORT=' "$workspace_dir/.env" | cut -d= -f2 | tr -d '"' || true)
        if [[ -n "$vite_port" ]]; then
            rails_port=$((vite_port + 2))
            server_url="http://localhost:$rails_port"
        fi
    fi

    echo -e "${GREEN}Resuming workspace: $feature${NC}"
    echo -e "  Project:             $project"
    echo -e "  Workspace directory: $workspace_dir"
    if [[ -n "$server_url" ]]; then
        echo -e "  Server URL:          $server_url"
    fi
    echo ""

    # Create tmux session
    echo -e "${YELLOW}Creating tmux session: $tmux_session${NC}"

    # Create tmux session with first window for coding
    tmux new-session -d -s "$tmux_session" -c "$workspace_dir" -n "code"

    # Open the feature's own docs file if it exists
    local docs_file=""
    if [[ -f "$workspace_dir/docs/$feature.md" ]]; then
        docs_file="$workspace_dir/docs/$feature.md"
    fi

    if [[ -n "$docs_file" ]]; then
        tmux send-keys -t "$tmux_session:code" "vim \"$docs_file\"" C-m
    else
        tmux send-keys -t "$tmux_session:code" "vim" C-m
    fi

    # Split first window vertically: vim on left, shell on right
    tmux split-window -h -t "$tmux_session:code" -c "$workspace_dir"

    # Create banner file and display in shell pane
    cat > "$workspace_dir/.banner" << EOF

   ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
   ┃  Project: $project
   ┃  Feature: $feature
   ┃  Server:  ${server_url:-"(unknown)"}
   ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

EOF
    tmux send-keys -t "$tmux_session:code.1" "clear && cat .banner" C-m

    # Create second window for server
    tmux new-window -t "$tmux_session" -c "$workspace_dir" -n "server"

    # Create a setup script that runs in the server window
    cat > "$workspace_dir/.workspace-setup.sh" << 'SETUP_SCRIPT'
#!/usr/bin/env bash
set -e

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

echo -e "${YELLOW}Setting up node version...${NC}"
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"
nvm use

echo -e "${YELLOW}Installing dependencies...${NC}"
echo -e "  Running bundle install..."
if ! bundle install; then
    echo -e "${RED}bundle install failed${NC}"
    exit 1
fi

echo -e "  Running yarn install..."
if ! yarn install; then
    echo -e "${RED}yarn install failed${NC}"
    exit 1
fi

echo ""
echo -e "${GREEN}Setup complete!${NC}"
echo ""
SETUP_SCRIPT

    # Append the server start to the setup script
    cat >> "$workspace_dir/.workspace-setup.sh" << EOF
echo ""
echo -e "${GREEN}Starting overmind...${NC}"
echo ""
rm -f "\$0"  # Clean up this script
exec overmind start -f Procfile.workspace
EOF

    chmod +x "$workspace_dir/.workspace-setup.sh"

    # Run the setup script in the server window
    tmux send-keys -t "$tmux_session:server" "./.workspace-setup.sh" C-m

    # Go back to first window, focus on vim pane
    tmux select-window -t "$tmux_session:code"
    tmux select-pane -t "$tmux_session:code.0"

    echo ""
    echo -e "${GREEN}Workspace resumed!${NC}"
    echo ""
    echo -e "  Tmux session: ${YELLOW}$tmux_session${NC}"
    if [[ -n "$server_url" ]]; then
        echo -e "  Server URL:   ${YELLOW}$server_url${NC}"
    fi
    echo ""
    echo -e "Switch to session:"
    echo -e "  ${YELLOW}tmux switch-client -t $tmux_session${NC}"
    echo ""
    echo -e "Or if not in tmux:"
    echo -e "  ${YELLOW}tmux attach -t $tmux_session${NC}"
}

# ============================================================================
# Claude session consolidation
# ============================================================================

# Move Claude Code conversation files from a worktree's project dir into the
# main repo's project dir so they appear in `claude resume` from the main repo.
consolidate_claude_sessions() {
    local worktree_path="$1"
    local main_repo_path="$2"

    # Encode paths the way Claude Code does: replace / with - and prepend -
    local worktree_encoded="${worktree_path//\//-}"
    local main_encoded="${main_repo_path//\//-}"

    local src="$HOME/.claude/projects/$worktree_encoded"
    local dst="$HOME/.claude/projects/$main_encoded"

    if [[ ! -d "$src" ]]; then
        return
    fi

    mkdir -p "$dst"

    local moved=0
    for jsonl in "$src"/*.jsonl; do
        [[ -f "$jsonl" ]] || continue
        local uuid
        uuid=$(basename "$jsonl" .jsonl)
        mv "$jsonl" "$dst/"
        [[ -d "$src/$uuid" ]] && mv "$src/$uuid" "$dst/"
        moved=$((moved + 1))
    done

    # Clean up the now-empty project dir (memory/ and anything else)
    rm -rf "$src"

    if [[ $moved -gt 0 ]]; then
        echo -e "${BLUE}Moved $moved Claude session(s) to main project${NC}"
    fi
}

# ============================================================================
# Subcommand: delete
# ============================================================================

cmd_delete() {
    local project="$1"
    local feature="$2"
    local force=false

    # Check for --force flag
    if [[ "$3" == "--force" ]]; then
        force=true
    fi

    if [[ -z "$project" ]] || [[ -z "$feature" ]]; then
        echo "Usage: workspace delete <project> <feature> [--force]"
        echo ""
        echo "Example: workspace delete tract my-feature"
        exit 1
    fi

    validate_project "$project"
    get_project_paths "$project"

    local workspace_dir
    workspace_dir=$(resolve_worktree_path "$project" "$feature")
    local tmux_session="${project}-${feature}"

    if [[ -z "$workspace_dir" ]]; then
        echo -e "${RED}Error: No worktree found for '$feature'${NC}"
        echo ""
        echo "Current worktrees for $project:"
        git -C "$PROJECT_PATH" worktree list
        exit 1
    fi

    # Prevent deleting the main directory
    if [[ "$workspace_dir" == "$PROJECT_PATH" ]]; then
        echo -e "${RED}Error: Cannot delete the main workspace${NC}"
        exit 1
    fi

    echo -e "${YELLOW}Workspace to delete: $feature${NC}"
    echo -e "  Project:   $project"
    echo -e "  Directory: $workspace_dir"
    echo ""

    # Kill tmux session if it exists
    if tmux has-session -t "$tmux_session" 2>/dev/null; then
        echo -e "${YELLOW}Killing tmux session: $tmux_session${NC}"
        tmux kill-session -t "$tmux_session"
    fi

    # Kill any overmind processes in that directory
    if [[ -f "$workspace_dir/.overmind.sock" ]]; then
        echo -e "${YELLOW}Stopping overmind...${NC}"
        (cd "$workspace_dir" && overmind quit 2>/dev/null) || true
    fi

    # Confirm deletion
    if [[ "$force" != true ]]; then
        read -p "Delete worktree at $workspace_dir? [y/N] " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Cancelled."
            exit 0
        fi
    fi

    # Remove the worktree
    echo -e "${YELLOW}Removing git worktree...${NC}"
    cd "$PROJECT_PATH"
    if ! git worktree remove "$workspace_dir" --force 2>/dev/null; then
        echo -e "${YELLOW}Worktree has untracked files, cleaning up manually...${NC}"
        rm -rf "$workspace_dir"
        git worktree prune
    fi

    # Move Claude Code sessions from the worktree to the main project
    consolidate_claude_sessions "$workspace_dir" "$PROJECT_PATH"

    # Ask about deleting the branch
    local branch_exists
    branch_exists=$(git branch --list "$feature")
    if [[ -n "$branch_exists" ]]; then
        local delete_branch
        if [[ "$force" == true ]]; then
            delete_branch="y"
        else
            read -p "Delete branch '$feature'? [y/N] " -n 1 -r delete_branch
            echo
        fi

        if [[ $delete_branch =~ ^[Yy]$ ]]; then
            echo -e "${YELLOW}Deleting branch: $feature${NC}"
            git branch -D "$feature"
        else
            echo -e "Branch '$feature' kept. Delete it later with: git branch -D $feature"
        fi
    fi

    echo ""
    echo -e "${GREEN}Workspace deleted successfully!${NC}"
}

# ============================================================================
# Subcommand: list
# ============================================================================

cmd_list() {
    local filter_project="$1"

    if [[ -n "$filter_project" ]]; then
        validate_project "$filter_project"
    fi

    local projects
    if [[ -n "$filter_project" ]]; then
        projects="$filter_project"
    else
        projects=$(list_projects)
    fi

    local found_any=false

    for project in $projects; do
        get_project_paths "$project"

        # Get worktrees for this project
        local worktrees
        worktrees=$(git -C "$PROJECT_PATH" worktree list 2>/dev/null || true)

        if [[ -z "$worktrees" ]]; then
            continue
        fi

        # Filter out the main project path, only show actual worktrees
        local workspace_worktrees
        workspace_worktrees=$(echo "$worktrees" | grep -v "^$PROJECT_PATH " || true)

        if [[ -n "$workspace_worktrees" ]]; then
            found_any=true
            echo -e "${CYAN}$project${NC}"

            while IFS= read -r line; do
                local path branch
                path=$(echo "$line" | awk '{print $1}')
                branch=$(echo "$line" | awk '{print $3}' | tr -d '[]')

                # Extract feature name from path
                local feature
                feature=$(basename "$path")

                # Check if tmux session exists
                local tmux_session="${project}-${feature}"
                local tmux_status=""
                if tmux has-session -t "$tmux_session" 2>/dev/null; then
                    tmux_status="${GREEN}[running]${NC}"
                fi

                # Check PR status via GitHub CLI
                local pr_status=""
                if command -v gh &>/dev/null; then
                    local origin_url
                    origin_url=$(git -C "$PROJECT_PATH" remote get-url origin)
                    local pr_state pr_url
                    pr_state=$(gh pr view "$branch" --repo "$origin_url" --json state --jq '.state' 2>/dev/null || true)
                    pr_url=$(gh pr view "$branch" --repo "$origin_url" --json url --jq '.url' 2>/dev/null || true)
                    case "$pr_state" in
                        OPEN)   pr_status="${YELLOW}[open]${NC}" ;;
                        MERGED) pr_status="${BLUE}[merged]${NC}" ;;
                        CLOSED) pr_status="${RED}[closed]${NC}" ;;
                    esac

                    # Add PR URL to docs file if missing
                    local docs_file="$path/docs/${feature}.md"
                    if [[ -n "$pr_url" && -f "$docs_file" ]] && ! grep -q "^PR:" "$docs_file"; then
                        sed -i '' "/^Path:/s|$|\nPR:          $pr_url|" "$docs_file"
                    fi
                fi

                echo -e "  $feature ($branch) $tmux_status ${pr_status}\n    $path"
            done <<< "$workspace_worktrees"
            echo ""
        fi
    done

    if [[ "$found_any" == false ]]; then
        if [[ -n "$filter_project" ]]; then
            echo "No workspaces found for project: $filter_project"
        else
            echo "No workspaces found."
        fi
    fi
}

# ============================================================================
# Main
# ============================================================================

usage() {
    echo "Usage: workspace <command> [args]"
    echo ""
    echo "Commands:"
    echo "  new <project> <feature>      Create a new workspace (new branch off master)"
    echo "  pull <project> <branch>      Pull a remote branch into a new workspace"
    echo "  resume <project> <feature>   Resume an existing workspace"
    echo "  delete <project> <feature>   Delete a workspace"
    echo "  list [project]               List all workspaces"
    echo ""
    echo "Examples:"
    echo "  workspace new tract my-feature"
    echo "  workspace pull tract remote-branch"
    echo "  workspace resume tract my-feature"
    echo "  workspace delete tract my-feature"
    echo "  workspace list"
    echo "  workspace list tract"
    echo ""
    echo "Config file: $CONFIG_FILE"
}

main() {
    local command="$1"
    shift || true

    case "$command" in
        new)
            check_config
            cmd_new "$@"
            ;;
        pull)
            check_config
            cmd_pull "$@"
            ;;
        resume)
            check_config
            cmd_resume "$@"
            ;;
        delete)
            check_config
            cmd_delete "$@"
            ;;
        list)
            check_config
            cmd_list "$@"
            ;;
        -h|--help|"")
            usage
            ;;
        *)
            echo -e "${RED}Unknown command: $command${NC}"
            echo ""
            usage
            exit 1
            ;;
    esac
}

main "$@"
